---
title: 深、浅拷贝
categories: 技术
tags: 知识点
abbrlink: ad2c1b4b
date: 2021-12-04 10:32:31
author: Zyx
---

### 生成指定深度和广度的对象

```javascript
function createData(deep, breadth) {
  var data = {};
  var temp = data;

  for (var i = 0; i < deep; i++) {
    temp = temp["data"] = {};
    for (var j = 0; j < breadth; j++) {
      temp[j] = j;
    }
  }

  return data;
}

// 1层深度，每层有3个数据
createData(1, 3); // {data: {0: 0, 1: 1, 2: 2}}

// 3层深度，每层有0个数据
createData(3, 0); // {data: {data: {data: {}}}}
```

### 浅拷贝 —— 一层拷贝

```javascript
function shallowClone(source) {
  var target = {};
  // key in Obj：判断自身或原型链上是否存在某个属性
  // for key in Obj: 遍历自身以及原型链上enumerable为true的可枚举属性，结合hasOwnProperty可以过滤掉原型链上的属性
  // Object.keys(Obj): 遍历自身的可枚举属性
  // Object.getOwnPropertyNames(Obj): 遍历自身的所有属性
  for (var i in source) {
    if (source.hasOwnProperty(i)) {
      target[i] = source[i];
    }
  }

  return target;
}
```

### 深拷贝 —— 无限层级拷贝

#### 扩展浅拷贝

```javascript
// 存在问题：1.未直接检验参数是否为对象；2.判断属性是否为对象的逻辑不严谨，未考虑null；3.未兼容多种数据格式，如Map、Set等；...
function deepClone(source) {
  var target = {};
  for (var i in source) {
    if (source.hasOwnProperty(i)) {
      if (typeof source[i] === "object") {
        target[i] = deepClone(source[i]);
      } else {
        target[i] = source[i];
      }
    }
  }

  return target;
}

// 递归，栈溢出
deepClone(createData(10000)); // Maximum call stack size exceeded

// 循环引用，栈溢出
let data = {};
data.data = data;
deepClone(data); // Maximum call stack size exceeded
```

#### 判断对象

```javascript
function isObject(x) {
  // 与typeof相比，能够区分null、array: typeof null === 'object'; typeof [1,2,3] === 'object'
  // 与toString()相比，调用的不是Object对象实例重写的方法而是Object原型对象的方法: [1,2,3].toString() === '1,2,3'; Object.prototype.toString.call([1,2,3]) === '[object Array]'
  // 不能准确判断自定义对象: function func() {}; Object.prototype.toString.call(new func()) === '[object Object]';
  return Object.prototype.toString.call(x) === "[object Object]";
}
```

#### 判断类型

```javascript
function type(x, strict = false) {
  // 将strict转换为布尔型
  strict = !!strict;

  // 解决 typeof null === 'object' 无法判断的问题
  if (x === null) {
    return "null";
  }

  const t = typeof x;

  // typeof NaN === 'number'
  if (strict && t === Number && isNaN(x)) {
    return "NaN";
  }

  // typeof 1 === 'number'
  // typeof '1' === 'string'
  // typeof false === 'boolean'
  // typeof undefined === 'undefined'
  // typeof Symbol() === 'symbol'
  // typeof function (){} === 'function'
  if (t !== "object") {
    return t;
  }

  let cls, clsLow;
  try {
    cls = Object.prototype.toString.call(x).slice(8, -1);
    clsLow = cls.toLowercase();
  } catch (e) {
    // ie，new ActiveXObject(String)报错
    return "object";
  }

  if (clsLow !== "object") {
    if (strict) {
      // Object.prototype.toString.call(new Number(NaN)) === '[object Number]'
      if (clsLow === "number" && isNaN(clsLow)) {
        return "NaN";
      }
      // Object.prototype.toString.call(new Number()) === '[object Number]'; 
      // Object.prototype.toString.call(new Boolean()) === '[object Boolean]'; 
      // Object.prototype.toString.call(new String()) === '[object String]'; 
      if (clsLow === "number" || clsLow === "boolean" || clsLow === "string") {
        return cls;
      }
    }
    // Object.prototype.toString.call([]) === '[object Array]'; 
    // Object.prototype.toString.call(new Array()) === '[object Array]'
    // Object.prototype.toString.call(new Set()) === '[object Set]'
    // Object.prototype.toString.call(new WeakSet()) === '[object WeakSet]'
    // Object.prototype.toString.call(new Map()) === '[object Map]'
    // Object.prototype.toString.call(new WeakMap()) === '[object WeakMap]'
    // Object.prototype.toString.call(new WeakRef({})) === '[object WeakRef]'
    return clsLow;
  }

  // Object.prototype.toString.call({}) === '[object Object]'; constructor: Object
  // Object.prototype.toString.call(new Object()) === '[object Object]'; constructor: Object
  if (x.constructor == Object) {
    return clsLow;
  }

  try {
    // Object.prototype.toString.call(Object.create(null)) === '[object Object]'; constructor: undefined
    // Object.getPrototypeOf(Object.create(null)) === null
    // x.__prototype__ === null 应用于早期firefox
    if (Object.getPrototypeOf(x) === null || x.__prototype__ === null) {
      return "object";
    }
  } catch (e) {
    // ie，无Object.getPrototypeOf会报错
  }

  try {
    // Object.prototype.toString.call(new function(){}) === '[object Object]'; constructor: f(){}（）
    const cname = x.constructor.name;
    if(typeof cname === 'string') {
      return cname;
    }
  } catch (e) {
    // 无constructor
  }

  // function A() {}; A.prototype.constructor = null; new A
  // new A instanceof A === true
  return 'unknown';
}
```

#### 通过 循环+栈 破解递归爆栈
```javascript
// 深度优先遍历
function cloneLoop(obj) {
    if(obj === null || typeof obj !== 'object') {
        return obj
    }

    const root = Array.isArray(obj) ? [] : {};
    // 用栈做中间节点缓存
    const stack = [ 
        {
            parent: root,
            key: undefined,
            value: obj,
        }
    ];

    while(stack.length) {
        const node = stack.pop();
        const { parent, key, value } = node;

        // 初始化赋值目标：key为undefined时拷贝到父元素，否则拷贝到子元素
        let res = parent;
        if (typeof key !== 'undefined') {
            res = parent[key] = Array.isArray(value) ? [] : {};
        }

        for(let prop in value) {
            if (data.hasOwnProperty(prop)) {
                if (prop && typeof value[prop] === 'object') {
                    stack.push({
                        parent: res,
                        key: prop,
                        value: value[prop],
                    });
                } else {
                    res[prop] = value[prop];
                }
            }
        }
    }

    return root;
}
```

#### 循环引用

1. 常见类型 
 
&emsp;(1) 对象之间相互引用 

```javascript  
    let obj1 = { name: '1' };
    let obj2 = { name: '2' };
    obj1.obj = obj2;
    obj2.obj = obj1;  
```  

&emsp;(2) 对象的属性引用对象本身  

```javascript
    // 直接引用最外层的对象
    let obj = { name: '1' };
    obj.child = obj;

    // 引用对象的部分属性
    let obj = { name: '1', child: {} };
    obj.child.child = obj.child;
```  

1. 判断循环引用
```javascript
const isCyclic = (obj) => {
    // 用Set数据类型存储检测过的对象
    let stackSet = new Set();
    let detected = false;

    const detect = (obj) => {
            if(obj && typeof obj != 'object') {
            return;
        }

        if(stackSet.has(obj)) {
            return detected = true;
        }

        stackSet.add(obj);

        for(let key in obj) {
            if(obj.hasOwnProperty(key)) {
                detect(obj[key]);
            }
        }

        // 平级检测完成之后，将当前对象删除
        stackSet.delete(obj);
    };

    detect(obj);

    return detected;
};
```

3. 用JSON.stringify输出有循环引用的对象
```javascript  
// 一行代码的深拷贝
// 只适用于JSON对象，无法处理function、正则表达式等
function cloneJSON(source) {
    return JSON.parse(JSON.stringify());
}

let obj = { };
obj.child = obj;
JSON.stringify(obj); // Uncaught TypeError: Converting circular structure to JSON

let cache = [];
JSON.stringify(obj, (key,value)=>{
    if(value && typeof value === 'object') {
        if(cache.indexOf(value) !== -1) {
            return;
        }
        cache.push(value);
    }
    return value;
});
cache = null;
```

## 参考链接

1. [深拷贝的终极探索（99%的人都不知道）](https://segmentfault.com/a/1190000016672263)
2. [用 Object.prototype.toString.call(obj)检测对象类型原因分析](https://www.jb51.net/article/148604.htm)
3. [详解 forin，Object.keys 和 Object.getOwnPropertyNames 的区别](https://yanhaijing.com/javascript/2015/05/09/diff-between-keys-getOwnPropertyNames-forin/)  
4. [如何优雅地嗅探”对象“是否存在”环“？](https://juejin.cn/post/7023898521010962462#heading-0)
5. [Javascript中的尾递归及其优化](https://zhuanlan.zhihu.com/p/47155064)
6. [尾调用和尾递归](https://juejin.cn/post/6844903590033621006#heading-11)
7. [利用深度/广度优先遍历手动实现JavaScript对象的深度拷贝](https://segmentfault.com/a/1190000019991949)