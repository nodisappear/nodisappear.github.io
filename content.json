{"meta":{"title":"XinAnXiaoZhan","subtitle":"","description":"","author":"ZYX&LZB","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2021-09-06T06:00:15.000Z","updated":"2022-02-19T08:57:58.273Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-09-07T12:51:56.000Z","updated":"2022-02-19T08:57:58.272Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-09-06T06:01:08.000Z","updated":"2022-02-19T08:57:58.273Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"H5移动端开发","slug":"H5移动端开发","date":"2022-03-01T13:03:00.000Z","updated":"2022-03-01T15:14:56.579Z","comments":true,"path":"8f9b8ba.html","link":"","permalink":"http://example.com/8f9b8ba.html","excerpt":"","text":"1. WebView控件Android应用层开发的方向有两种：客户端开发和HTML5移动端开发。HTML5开发就是：HTML5 + CSS + JS来构建 一个网页版的应用, 而这中间的媒介就是这个WebView。WebView和网页端可以通过JS来进行交互, 比如,网页读取手机联系人,调用手机相关的API等！ 1.1 什么是WebViewAndroid内置webkit内核的高性能浏览器,而WebView则是在这个基础上进行封装后的一个 控件,WebView直译网页视图,我们可以简单的看作一个可以嵌套到界面上的一个浏览器控件. WebView通过 loadUrl 这个API加载 html 文件，如果是加载本地文件直接使用 file://协议【注：在hatom中线上编译后就是将前端资源作为本地静态文件来进行访问】，也可以加载网络资源。 2. 需要注意的问题移动端H5开发, 采用了 WebView 这个中间件，和真实的浏览器环境还是有很多不一样的，因此会存在很多大大小小的坑，稍不注意就踩进去了。 2.1 window.location浏览器中通常会使用 window.location 来获取网页当前的url, 协议，主机名等内容 在webview中，使用 file:// 加载前端资源是，是不能正常使用window.location的。 2.2 window.localStorageios系统上使用localStorage不会生效，原因是ios上 WebView 是独占进程的，每个WebView都是新的进程，也就是每个WebView都有自己的localstorage, 相互之间不会共享。解决方法就是使用 hatom.storage.setItem 写入手机缓存中。参考： https://hatom2.hikyun.com/doc/h5-developer/api/storage.html 3. 常用的工具函数3.1 判断当前的设备类型移动端常用的ios系统和安卓操作系统，在两种机型上经常会有一些适配性问题。因此判断当前的设备类型这种操作就比较常见 1234567891011121314151617let ua = window.navigator.userAgent, app = window.navigator.appVersion;alert(&#x27;浏览器版本: &#x27; + app + &#x27;\\n&#x27; + &#x27;用户代理: &#x27; + ua);if(!!ua.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/))&#123; // ios端 console.log(&#x27;ios端&#x27;);&#125;else if(ua.indexOf(&#x27;Android&#x27;) &gt; -1 || ua.indexOf(&#x27;Adr&#x27;) &gt; -1) &#123; // android端 console.log(&#x27;android端&#x27;);&#125;if (ua.match(/MicroMessenger/i) == &#x27;MicroMessenger&#x27;) &#123; // 微信浏览器 console.log(&#x27;微信浏览器&#x27;);&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF/"}],"author":"Lzb"},{"title":"javascript事件循环机制","slug":"javascript事件循环机制","date":"2022-02-20T17:19:00.000Z","updated":"2022-03-01T15:07:49.117Z","comments":true,"path":"182c94d6.html","link":"","permalink":"http://example.com/182c94d6.html","excerpt":"","text":"1.JavaScript是单线程语言Javascript语言是一种单线程语言，所有任务都在一个线程上完成。单线程如果遇到某个任务比较耗时，比如涉及很多I/O操作：读取文件、HTTP请求、SQL查询等，线程的大部分运行时间都会在空等I/O操作的返回结果。Event Loop就是为了解决单线程语言的这个问题。 2.事件循环Event Loop为了解决JavaScript这种单线程语言带来的堵塞问题，Javascript程序会在程序中设置两个线程：一个负责程序本身的运行，称为主线程；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为”Event Loop线程”。Event Loop线程中主线程从任务队列中读取事件，这个过程是循环不断得，所以整个的这种运行机制又被称为事件循环。在事件循环中，异步事件并不会放到当前任务执行队列，而是会被挂起，放入另外一个回调队列。当前的任务队列执行结束以后，JavaScript引擎回去检查回调队列中是否有等待执行的任务【Perform a microtask checkpoint, 即执行微任务检查点】，若有会把第一个任务加入执行队列，然后不断的重复这个过程。JavaScrip是单线程，因此同一个执行队列产生的微任务总是会在宏任务之前被执行。 2.1 宏任务与微任务宏任务必然是在微任务之后才执行。宏任务： setTimeout setInterval I/O setImmediate[在浏览器中是微任务，在Node中是宏任务] requestAnimationFrame[在浏览器中是宏任务，在Node中是微任务] 微任务： Promise.then / catch / finally / async/await本质上还是基于Promise的一些封装 process.nextTick[在Node中是微任务] MutationObserver[在浏览器中是微任务] 3. javascript执行上下文和执行栈JavaScript 中有三种执行上下文类型： 全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。 函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。 Eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。 执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。 4. 示例12345678910111213141516171819202122console.log(1);setTimeout(() =&gt; &#123;console.log(2)&#125;, 1000)async function fn() &#123; console.log(3) setTimeout(() =&gt; &#123;console.log(4)&#125;, 20) return Promise.resolve()&#125;async function run() &#123; console.log(5) await fn() console.log(6)&#125;run()for(let i=0; i&lt;50000000000; i++) &#123;&#125;setTimeout(() =&gt; &#123; console.log(7) new Promise(resolve =&gt; &#123; console.log(8) resolve() &#125;).then(() =&gt; &#123;console.log(9)&#125;)&#125;, 0)console.log(10)","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"author":"Lzb"},{"title":"core-decorator源码解析","slug":"core-decorator源码解析","date":"2021-12-15T03:21:00.000Z","updated":"2022-02-19T08:57:58.267Z","comments":true,"path":"b483b17d.html","link":"","permalink":"http://example.com/b483b17d.html","excerpt":"","text":"一. core-decorator装饰器库core-decorator是封装了一些常用功能的装饰器库，采用了es6的装饰器语法，可以装饰类和类的方法。 二. es6的装饰器语法装饰器是一种函数，写成 @ + 函数名，它可以放在类和类方法的定义前面。 1. 默认参数列表(1) 装饰类 默认参数列表中包含一个参数，即要装饰的目标类; (2) 装饰类的方法 默认参数列表中三个参数:第一个是要装饰的类的实例target【但这个时候实例还未生成，所以实际装饰的是类的原型】； 第二个key是要装饰的属性名；第三个参数descriptor是属性的描述对象【描述对象中包含的属性有：’value’, ‘initializer’, ‘get’, ‘set’, ‘writable’, ‘enumerable’】 三. 主要流程以防抖的装饰器debounce为例 1. 封装一个装饰器的功能函数handleDescriptor这里metaFor只是绑定在this对象上、保存定时器ID的对象 12345678910111213141516171819202122232425262728293031323334import &#123; decorate, metaFor, internalDeprecation &#125; from &#x27;./private/utils&#x27;;const DEFAULT_TIMEOUT = 300;function handleDescriptor(target, key, descriptor, [wait = DEFAULT_TIMEOUT, immediate = false]) &#123; const callback = descriptor.value; if (typeof callback !== &#x27;function&#x27;) &#123; throw new SyntaxError(&#x27;Only functions can be debounced&#x27;); &#125; return &#123; ...descriptor, value() &#123; const &#123; debounceTimeoutIds &#125; = metaFor(this); const timeout = debounceTimeoutIds[key]; const callNow = immediate &amp;&amp; !timeout; const args = arguments; clearTimeout(timeout); debounceTimeoutIds[key] = setTimeout(() =&gt; &#123; delete debounceTimeoutIds[key]; if (!immediate) &#123; callback.apply(this, args); &#125; &#125;, wait); if (callNow) &#123; callback.apply(this, args); &#125; &#125; &#125;;&#125; 2. 对外暴露整个装饰器将功能函数handleDescriptor、默认参数列表作为参数传递给装饰器的工具函数decoratoe， 并对外暴露。 这里internalDeprecation只是一个在调用时显示是否deprecated的工具函数。 1234export default function debounce(...args) &#123; internalDeprecation(&#x27;@debounce is deprecated and will be removed shortly. Use @debounce from lodash-decorators.\\n\\n https://www.npmjs.com/package/lodash-decorators&#x27;); return decorate(handleDescriptor, args);&#125; 3. 装饰器decorate函数的主要逻辑decorate主要对是否传递额外参数做了一下判断，其中怎么参数涉及的过程还是略微复杂的, 不明白可以参照 js-learning/decortor/core-decorator-test.js下的实际过程加深了解。 123456789101112131415161718192021222324252627export function isDescriptor(desc) &#123; if (!desc || !desc.hasOwnProperty) &#123; return false; &#125; const keys = [&#x27;value&#x27;, &#x27;initializer&#x27;, &#x27;get&#x27;, &#x27;set&#x27;]; for (let i = 0, l = keys.length; i &lt; l; i++) &#123; if (desc.hasOwnProperty(keys[i])) &#123; return true; &#125; &#125; return false;&#125;export function decorate(handleDescriptor, entryArgs) &#123; if (isDescriptor(entryArgs[entryArgs.length - 1])) &#123; // 没有额外参数的情况下，entryArgs就是默认参数列表 [target, key descriptor] return handleDescriptor(...entryArgs, []); &#125; else &#123; return function () &#123; // Array.prototype.slice.call(arguments) 这个是编译时的最外层调用的默认参数列表 [target, key descriptor] return handleDescriptor(...Array.prototype.slice.call(arguments), entryArgs); &#125;; &#125;&#125; 参考文献[1] core-decorator的github地址 [2] ECMAScript6入门","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"源码","slug":"源码","permalink":"http://example.com/tags/%E6%BA%90%E7%A0%81/"}],"author":"Lzb"},{"title":"深浅拷贝","slug":"深、浅拷贝","date":"2021-12-04T02:32:31.000Z","updated":"2022-02-19T08:57:58.271Z","comments":true,"path":"ad2c1b4b.html","link":"","permalink":"http://example.com/ad2c1b4b.html","excerpt":"","text":"生成指定深度和广度的对象12345678910111213141516function createData(deep, breadth) &#123; var data = &#123;&#125;; var temp = data; for (var i = 0; i &lt; deep; i++) &#123; temp = temp[&quot;data&quot;] = &#123;&#125;; for (var j = 0; j &lt; breadth; j++) &#123; temp[j] = j; &#125; &#125; return data;&#125;// 2层深度，每层有3个数据createData(1, 3); 浅拷贝 —— 一层拷贝 遍历属性1234567891011121314function shallowClone(source) &#123; var target = &#123;&#125;; // key in Obj：判断自身或原型链上是否存在某个属性 // for key in Obj: 遍历自身以及原型链上enumerable为true的可枚举属性，结合hasOwnProperty可以过滤掉原型链上的属性 // Object.keys(Obj): 遍历自身的可枚举属性 // Object.getOwnPropertyNames(Obj): 遍历自身的所有属性 for (var i in source) &#123; if (source.hasOwnProperty(i)) &#123; target[i] = source[i]; &#125; &#125; return target;&#125; Object.assign(target, …sources) { …source } lodash.clone12let _ = require(&#x27;lodash&#x27;);_.clone(source); 深拷贝 —— 无限层级拷贝 扩展浅拷贝 [不推荐] 1234567891011121314151617181920212223// 存在问题：1.未直接检验参数是否为对象；2.判断属性是否为对象的逻辑不严谨，未考虑null；3.未兼容多种数据格式，如Map、Set等；...function deepClone(source) &#123; var target = &#123;&#125;; for (var i in source) &#123; if (source.hasOwnProperty(i)) &#123; if (typeof source[i] === &quot;object&quot;) &#123; target[i] = deepClone(source[i]); &#125; else &#123; target[i] = source[i]; &#125; &#125; &#125; return target;&#125;// 递归，栈溢出deepClone(createData(10000)); // Maximum call stack size exceeded// 循环引用，栈溢出let data = &#123;&#125;;data.data = data;deepClone(data); // Maximum call stack size exceeded JSON.parse(JSON.stringify(source)) [适用于JSON对象, 不保留引用，会爆栈] 构造函数 + 集合 [可保留引用，会爆栈]123456789101112131415function deepClone(source, hash = new WeakMap()) &#123; if (source === null) return source; if (source instanceof Date) return new Date(source); if (source instanceof RegExp) return new RegExp(source); if (typeof source !== &quot;object&quot;) return source; if (hash.get(source)) return hash.get(source); let target = new source.constructor(); hash.set(source, target); for (let key in source) &#123; if (source.hasOwnProperty(key)) &#123; target[key] = deepClone(source[key], hash); &#125; &#125; return target;&#125; lodash.cloneDeep12let _ = require(&#x27;lodash&#x27;);_.cloneDeep(source); deepmerge12const merge = require(&#x27;deepmerge&#x27;);merge(target, source); 扩展内容1. 判断对象123456function isObject(x) &#123; // 与 typeof x 相比，能够区分null、array: typeof null === &#x27;object&#x27;; typeof [1,2,3] === &#x27;object&#x27; // 与 x.toString() 相比，调用的不是Object对象实例重写的方法而是Object原型对象的方法: [1,2,3].toString() === &#x27;1,2,3&#x27;; Object.prototype.toString.call([1,2,3]) === &#x27;[object Array]&#x27; // 不能准确判断自定义对象: function func() &#123;&#125;; Object.prototype.toString.call(new func()) === &#x27;[object Object]&#x27;; return Object.prototype.toString.call(x) === &quot;[object Object]&quot;;&#125; 2. 判断类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889function type(x, strict = false) &#123; // 将strict转换为布尔型 strict = !!strict; // 解决 typeof null === &#x27;object&#x27; 无法判断的问题 if (x === null) &#123; return &quot;null&quot;; &#125; const t = typeof x; // typeof NaN === &#x27;number&#x27; if (strict &amp;&amp; t === Number &amp;&amp; isNaN(x)) &#123; return &quot;NaN&quot;; &#125; // typeof 1 === &#x27;number&#x27; // typeof &#x27;1&#x27; === &#x27;string&#x27; // typeof false === &#x27;boolean&#x27; // typeof undefined === &#x27;undefined&#x27; // typeof Symbol() === &#x27;symbol&#x27; // typeof function ()&#123;&#125; === &#x27;function&#x27; if (t !== &quot;object&quot;) &#123; return t; &#125; let cls, clsLow; try &#123; cls = Object.prototype.toString.call(x).slice(8, -1); clsLow = cls.toLowercase(); &#125; catch (e) &#123; // ie，new ActiveXObject(String)报错 return &quot;object&quot;; &#125; if (clsLow !== &quot;object&quot;) &#123; if (strict) &#123; // Object.prototype.toString.call(new Number(NaN)) === &#x27;[object Number]&#x27; if (clsLow === &quot;number&quot; &amp;&amp; isNaN(clsLow)) &#123; return &quot;NaN&quot;; &#125; // Object.prototype.toString.call(new Number()) === &#x27;[object Number]&#x27;; // Object.prototype.toString.call(new Boolean()) === &#x27;[object Boolean]&#x27;; // Object.prototype.toString.call(new String()) === &#x27;[object String]&#x27;; if (clsLow === &quot;number&quot; || clsLow === &quot;boolean&quot; || clsLow === &quot;string&quot;) &#123; return cls; &#125; &#125; // Object.prototype.toString.call([]) === &#x27;[object Array]&#x27;; // Object.prototype.toString.call(new Array()) === &#x27;[object Array]&#x27; // Object.prototype.toString.call(new Set()) === &#x27;[object Set]&#x27; // Object.prototype.toString.call(new WeakSet()) === &#x27;[object WeakSet]&#x27; // Object.prototype.toString.call(new Map()) === &#x27;[object Map]&#x27; // Object.prototype.toString.call(new WeakMap()) === &#x27;[object WeakMap]&#x27; // Object.prototype.toString.call(new WeakRef(&#123;&#125;)) === &#x27;[object WeakRef]&#x27; return clsLow; &#125; // Object.prototype.toString.call(&#123;&#125;) === &#x27;[object Object]&#x27;; constructor: Object // Object.prototype.toString.call(new Object()) === &#x27;[object Object]&#x27;; constructor: Object if (x.constructor == Object) &#123; return clsLow; &#125; try &#123; // Object.prototype.toString.call(Object.create(null)) === &#x27;[object Object]&#x27;; constructor: undefined // Object.getPrototypeOf(Object.create(null)) === null // x.__prototype__ === null 应用于早期firefox if (Object.getPrototypeOf(x) === null || x.__prototype__ === null) &#123; return &quot;object&quot;; &#125; &#125; catch (e) &#123; // ie，无Object.getPrototypeOf会报错 &#125; try &#123; // Object.prototype.toString.call(new function()&#123;&#125;) === &#x27;[object Object]&#x27;; constructor: f()&#123;&#125;（） const cname = x.constructor.name; if(typeof cname === &#x27;string&#x27;) &#123; return cname; &#125; &#125; catch (e) &#123; // 无constructor &#125; // function A() &#123;&#125;; A.prototype.constructor = null; new A // new A instanceof A === true return &#x27;unknown&#x27;;&#125; 3. 通过 “循环+栈” 破解 “递归爆栈”&emsp;(1) 深度优先遍历, 用栈做中间节点缓存 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function deepLoopClone(obj) &#123; if(obj === null || typeof obj !== &#x27;object&#x27;) &#123; return obj &#125; // 保留不同属性之间存在的引用关系 const uniqueList = []; const root = Array.isArray(obj) ? [] : &#123;&#125;; const stack = [ &#123; parent: root, key: undefined, value: obj, &#125; ]; while(stack.length) &#123; const node = stack.pop(); const &#123; parent, key, value &#125; = node; let res = parent; if (typeof key !== &#x27;undefined&#x27;) &#123; res = parent[key] = Array.isArray(value) ? [] : &#123;&#125;; &#125; let uniqueData = find(uniqueList, value); if(uniqueData) &#123; parent[key] = uniqueData.target; break; &#125; uniqueList.push(&#123; source: value, target: res &#125;); for(let prop in value) &#123; if (value.hasOwnProperty(prop)) &#123; if (prop &amp;&amp; typeof value[prop] === &#x27;object&#x27;) &#123; stack.push(&#123; parent: res, key: prop, value: value[prop], &#125;); &#125; else &#123; res[prop] = value[prop]; &#125; &#125; &#125; &#125; return root;&#125;// 查找对象function find(arr, item) &#123; for(let i = 0; i &lt; arr.length; i++) &#123; if (arr[i].source === item) &#123; return arr[i]; &#125; &#125; return null;&#125; &emsp;(2) 广度优先遍历, 用队列做中间节点缓存 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function rangeLoopClone(obj) &#123; if(obj === null || typeof obj !== &#x27;object&#x27;) &#123; return obj; &#125; // 保留不同属性之间存在的引用关系 const uniqueList = []; const root = Array.isArray(obj) ? [] : &#123;&#125;; const queue = [ &#123; parent: root, key: undefined, value: obj, &#125; ]; while(queue.length) &#123; const node = queue.shift(); const &#123; parent, key, value &#125; = node; if (typeof key !== &#x27;undefined&#x27;) &#123; res = parent[key] = Array.isArray(value) ? [] : &#123;&#125;; &#125; let uniqueData = find(uniqueList, value); if(uniqueData) &#123; parent[key] = uniqueData.target; break; &#125; uniqueList.push(&#123; source: value, target: res &#125;); for(let prop in value) &#123; if (value.hasOwnProperty(prop)) &#123; if (prop &amp;&amp; typeof value[prop] === &#x27;object&#x27;) &#123; queue.push(&#123; parent: res, key: prop, value: value[prop], &#125;); &#125; else &#123; res[prop] = value[prop]; &#125; &#125; &#125; &#125; return root;&#125;// 查找对象function find(arr, item) &#123; for(let i = 0; i &lt; arr.length; i++) &#123; if (arr[i].source === item) &#123; return arr[i]; &#125; &#125; return null;&#125; 4. 循环引用&emsp;(1) 常见类型 对象之间相互引用1234let obj1 = &#123; name: &#x27;1&#x27; &#125;;let obj2 = &#123; name: &#x27;2&#x27; &#125;;obj1.obj = obj2;obj2.obj = obj1; 对象的属性引用对象本身 1234567// 直接引用最外层的对象let obj = &#123; name: &#x27;1&#x27; &#125;;obj.child = obj;// 引用对象的部分属性let obj = &#123; name: &#x27;1&#x27;, child: &#123;&#125; &#125;;obj.child.child = obj.child; &emsp;(2) 判断循环引用 123456789101112131415161718192021222324252627282930const isCyclic = (obj) =&gt; &#123; // 用Set数据类型存储检测过的对象 let stackSet = new Set(); let detected = false; const detect = (obj) =&gt; &#123; if(obj &amp;&amp; typeof obj != &#x27;object&#x27;) &#123; return; &#125; if(stackSet.has(obj)) &#123; return detected = true; &#125; stackSet.add(obj); for(let key in obj) &#123; if(obj.hasOwnProperty(key)) &#123; detect(obj[key]); &#125; &#125; // 平级检测完成之后，将当前对象删除 stackSet.delete(obj); &#125;; detect(obj); return detected;&#125;; &emsp;(3) 用JSON.stringify输出有循环引用的对象 12345678910111213141516let obj = &#123; &#125;;obj.child = obj;// JSON.stringify()内部做了循环引用的检测JSON.stringify(obj); // Uncaught TypeError: Converting circular structure to JSONlet cache = [];JSON.stringify(obj, (key,value)=&gt;&#123; if(value &amp;&amp; typeof value === &#x27;object&#x27;) &#123; if(cache.indexOf(value) !== -1) &#123; return; &#125; cache.push(value); &#125; return value;&#125;);cache = null; 参考链接 深拷贝的终极探索（99%的人都不知道） 用 Object.prototype.toString.call(obj)检测对象类型原因分析 详解 forin，Object.keys 和 Object.getOwnPropertyNames 的区别 如何优雅地嗅探”对象“是否存在”环“？ Javascript中的尾递归及其优化 尾调用和尾递归 利用深度/广度优先遍历手动实现JavaScript对象的深度拷贝","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}],"author":"Zyx"},{"title":"读《JavaScript设计模式核心原理与应用实践》","slug":"读《JavaScript设计模式核心原理与应用实践》","date":"2021-11-03T08:18:10.000Z","updated":"2022-02-19T08:57:58.272Z","comments":true,"path":"806a46bc.html","link":"","permalink":"http://example.com/806a46bc.html","excerpt":"","text":"掘金小册——JavaScript 设计模式核心原理与应用实践 开篇：前端工程师的成长论一. 软件工程师的核心竞争力&ensp;驾驭技术的能力 能用健壮的代码解决具体问题 能用抽象的思维应对复杂系统 能用工程化思想规划大型业务 设计模式的“道”与“术”一. 设计模式的指导理论&ensp;SOLID 设计原则 *单一职责 [单一功能] *开放封闭 —— 对扩展开放，对修改封闭 类、模块、函数等软件实体可以扩展，但不可以修改 李式置换 [里式替换] 接口独立 [接口隔离] 依赖导致 [依赖反转] 二. 设计模式的核心思想&ensp;封装变化 &ensp;观察整个逻辑里面的变与不变并分离它们，使变化的部分灵活而不变的部分稳定 三. 23 种设计模式&ensp;创建型 —— 封装创建对象过程中的变化 单例模式 原型模式 构造器模式 工厂模式 抽象工厂模式 &ensp;结构型 —— 封装对象之间组合方式的变化 桥接模式 外观模式 组合模式 装饰器模式 适配器模式 代理模式 享元模式 &ensp;行为型 —— 封装对象千变万化的行为 迭代器模式 解释器模式 观察者模式 中介者模式 访问者模式 状态模式 备忘录模式 策略模式 模板方法模式 职责链模式 命令模式 创建型：工厂模式 —— 区分“变与不变”一. 构造器模式&ensp;用构造函数初始化对象 —— 抽象不同对象实例之间的变与不变 123456789// 将赋值过程封装，确保每个对象具备 共性function User(name, age, career) &#123; this.name = name; this.age = age; this.career = career;&#125;// 将取值操作开放，确保每个对象具备 个性const user = new User(&quot;李雷&quot;, 25, &quot;coder&quot;); 二. 简单工厂模式&ensp;将创建对象的过程单独封装 —— 抽象不同构造函数之间的变与不变 1234567891011121314151617181920function User(name, age, career, work) &#123; this.name = name; this.age = age; this.career = career; this.work = work;&#125;// 将 承载共性的构造函数 和 承载个性的逻辑判断 写入同一函数function Factory(name, age, career) &#123; let work; switch (career) &#123; case &quot;boss&quot;: work = [&quot;喝茶&quot;, &quot;看报&quot;, &quot;见客户&quot;]; break; case &quot;coder&quot;: work = [&quot;写代码&quot;, &quot;写系分&quot;, &quot;修Bug&quot;]; break; &#125; return new User(&quot;李雷&quot;, 25, &quot;coder&quot;);&#125; &ensp;重要提示：&emsp;在写了大量构造函数、调用了大量 new 的情况下，就应该思考是不是可以用工厂模式重构代码了！ 三. 抽象工厂模式&ensp;围绕一个超级工厂创建其他工厂 —— 遵循“开放封闭”设计原则 &ensp;将一个复杂场景中不同的类按性质划分为 4 个关键角色[1 - 4]： &nbsp;0. 超级工厂：拥有多个抽象工厂的系统 【电子厂】 抽象工厂：抽象类，用于声明最终目标产品的共性，每个抽象工厂对应的一类产品称为“产品族” 【手机厂，电脑厂，…】 具体工厂：继承自抽象工厂，用于生成产品族里的一类具体产品 【智能手机厂，非智能手机厂，…】 抽象产品：抽象类，用于声明具体产品所依赖的细粒度产品的共性 【操作系统厂，硬件厂，…】 具体产品： 继承自抽象产品，用于生成具体产品所依赖的细粒度产品 【安卓操作系统厂/苹果操作系统厂，小米硬件厂/高通硬件厂，…】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 抽象工厂，定义手机的共性class MobilePhoneFactory &#123; createOS() &#123; // 提供操作系统的接口 throw new Error(&quot;抽象工厂方法不允许直接调用，你需要将我重写！&quot;); &#125; createHardWare() &#123; // 提供硬件的接口 throw new Error(&quot;抽象工厂方法不允许直接调用，你需要将我重写！&quot;); &#125;&#125;// 具体工厂，用于生成手机实例class FakeStarFactory extends MobilePhoneFactory &#123; createOS() &#123; // 提供操作系统实例 return new AndroidOS(); &#125; createHardWare() &#123; // 提供硬件实例 return new QualcommHardWare(); &#125;&#125;// 抽象产品，定义手机操作系统的共性class OS &#123; controlHardWare() &#123; throw new Error(&quot;抽象产品方法不允许直接调用，你需要将我重写！&quot;); &#125;&#125;// 具体产品，定义具体的手机操作系统class AndroidOS extends OS &#123; controlHardWare() &#123; console.log(&quot;操作系统：我会用安卓的方式去操作硬件&quot;); &#125;&#125;// 抽象产品，定义手机硬件的共性class HardWare &#123; operateByOrder() &#123; throw new Error(&quot;抽象产品方法不允许直接调用，你需要将我重写！&quot;); &#125;&#125;// 具体产品：定义具体的手机硬件class QualcommHardWare extends HardWare &#123; operateByOrder() &#123; console.log(&quot;硬件：我会用高通的方式去运转&quot;); &#125;&#125;// 生产一台拥有安卓操作系统和高通硬件的手机const myMobilePhone = new FakeStarFactory(); // 创建手机实例const myOS = myMobilePhone.createOS(); // 添加操作系统const myHardWare = myMobilePhone.createHardWare(); // 添加硬件myOS.controlHardWare(); // 启动操作系统myHardWare.operateByOrder(); // 启动硬件// 扩展具体工厂， 生产一款新的手机class newStarFactory extends MobilePhoneFactory &#123; createOS() &#123;&#125; createHardWare() &#123;&#125;&#125; &ensp;重要提示：&emsp;1. 抽象工厂和简单工厂的共同之处是都基于“封装变化”的思想去分离一个系统中变与不变的部分，不同之处是应用的场景复杂度不同，简单工厂的处理对象是不苛求可扩展性的简单类，抽象工厂的处理对象是存在各种扩展可能性的能进一步划分的复杂类。&emsp;2. 抽象工厂目前在 JS 中应用得并不广泛，需要留意三点：(1) 学会用 ES6 模拟 Java 中的抽象类；(2) 了解抽象工厂模式中四个角色的定位和作用；(3) 理解“开放封闭”设计原则，知道它的好用之处和执行之必要性。 创建型：单例模式 —— Vuex 的数据管理哲学一. 单例模式的实现思路&ensp;保证一个类仅有一个实例，并提供一个访问它的全局访问点 —— 不管尝试创建多少次，都只返回第一次创建的实例 &ensp;构造函数需要具备判断自己是否已经创建过一个实例的能力 12345678910111213141516171819202122232425262728293031// 1.判断逻辑写在静态方法中class SingleDog &#123; constructor() &#123; this.instance = null; &#125; static getInstance() &#123; if (!this.instance) &#123; this.instance = new SingleDog(); &#125; return this.instance; &#125;&#125;const s1 = SingleDog.getInstance();const s2 = SingleDog.getInstance();// 2.判断逻辑写在闭包中function SingleDog() &#123;&#125;const getInstance = (function () &#123; let instance = null; return function () &#123; if (!instance) &#123; instance = new SingleDog(); &#125; return instance; &#125;;&#125;)();const s1 = getInstance();const s2 = getInstance();// s1和s2都指向唯一的实例s1 === s2; // true 二. 生产实践：Vuex 中的单例模式理解 Vuex 中的 Store 引入 Vuex 插件 1234import Vue from &quot;vue&quot;;import Vuex from &quot;vuex&quot;;Vue.use(Vuex); Vue.use 源码 123456789101112131415161718192021222324252627282930313233// 截取参数function toArray(list: any, start?: number): Array&lt;any&gt; &#123; start = start || 0; let i = list.length - start; const ret: Array&lt;any&gt; = new Array(i); while (i--) &#123; ret[i] = list[i + start]; &#125; return ret;&#125;// 注册插件export function initUse(Vue: GlobalAPI) &#123; Vue.use = function (plugin: Function | Object) &#123; const installedPlugins = this._installedPlugins || (this._installedPlugins = []); // 已安装插件列表 if (installedPlugins.indexOf(plugin) &gt; -1) &#123; // 防止重复注册 return this; &#125; const args = toArray(arguments, 1); args.unshift(this); if (typeof plugin.install === &quot;function&quot;) &#123; // 如果插件是一个对象，必须提供install方法 plugin.install.apply(plugin, args); &#125; else if (typeof plugin === &quot;function&quot;) &#123; // 如果插件是一个函数，它会被直接当作install方法 plugin.apply(null, args); &#125; installedPlugins.push(plugin); return this; &#125;;&#125; Vuex install 源码 123456789101112131415161718192021222324252627let vue; // instancefunction install(_Vue) &#123; if (Vue &amp;&amp; _Vue === Vue) &#123; // 判断传入的Vue实例对象是否已经被install过Vuex插件 if (__DEV__) &#123; console.error( &quot;[vuex] already installed. Vue.use(Vuex) should be called only once.&quot; ); &#125; return; &#125; Vue = _Vue; // 若没有，为该Vue实例对象install一个唯一的Vuex applyMixin(Vue); // 将Vuex的初始化逻辑写进Vue的钩子函数里&#125;// applyMixin(Vue)function vuexInit() &#123; const options = this.$options; // 当前Vue实例的初始化选项 if (options.store) &#123; // 根实例有store this.$store = typeof options.store === &quot;function&quot; ? options.store() : options.store; &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123; // 根实例没有store，就找父节点的store this.$store = options.parent.$store; &#125;&#125;Vue.mixin(&#123; beforeCreate: vuexInit &#125;); // 全局混入 创建 store 123456const store = new Vuex.Store(&#123; state: &#123;&#125;, mutations: &#123;&#125;, actions: &#123;&#125;, modules: &#123;&#125;,&#125;); 将 store 注入到 Vue 实例中 1234new Vue(&#123; el: &quot;#app&quot;, store,&#125;); 创建型：原型模式 —— 谈 Prototype 无小事一. 以类为中心的语言和以原型为中心的语言&ensp;以类为中心的语言，原型模式不是必选项，它只用于特定场景 &ensp;Java在大多数情况下以“实例化类”的方式来创建对象，虽然专门针对原型模式设计了一套接口和方法，但是只在必要场景下通过原型方法来应用原型模式，实现类型之间的解耦 123// 实例化类：通过传递相同的参数来创建相同的实例Dog dog = new Dog(&#x27;旺财&#x27;, &#x27;male&#x27;, 3, &#x27;柴犬&#x27;)Dog dog_copy = new Dog(&#x27;旺财&#x27;, &#x27;male&#x27;, 3, &#x27;柴犬&#x27;) &ensp;以原型为中心的语言，原型模式是根基，是一种编程范式 &ensp;JavaScript本身类型比较模糊，不存在类型耦合的问题，使用原型模式不是为了得到一个副本，而是为了得到与构造函数（类）相对应类型的实例，实现数据和方法的共享 二. 谈原型模式，其实是谈原型范式&ensp;在JavaScript中，原型编程范式的体现就是基于原型链的继承 1. 原型&ensp;(1) 每个构造函数都有一个prototype属性指向其原型对象，而其原型对象又有一个constructor属性指回构造函数本身&ensp;(2) 每个实例都有一个__proto__属性，使用构造函数创建实例时，实例的__proto__属性就会指向构造函数的原型对象 1234567891011121314151617181920212223// 创建Dog构造函数// Dog.prototype.constructor === Dogfunction Dog(name, age) &#123; this.name = name this.age = age&#125;Dog.prototype.eat = function() &#123; console.log(&#x27;肉骨头真好吃&#x27;)&#125;// 使用Dog构造函数创建dog实例// dog.__proto__ === Dog.prototype// dog.hasOwnProperty(&#x27;name&#x27;) === true; dog.hasOwnProperty(&#x27;age&#x27;) === true// dog.eat === Dog.prototype.eat; dog.hasOwnProperty(&#x27;eat&#x27;) === falseconst dog = new Dog(&#x27;旺财&#x27;, 3)// 原型链： 实例 -&gt; 实例的原型对象 -&gt; 实例的原型对象的原型对象 ... -&gt; Object// dog -&gt; dog.__proto__(Dog.prototype) -&gt; Dog.prototype.__proto__(Object.prototype)// Object.prototype.__proto__ === nulldog.toString() === &#x27;[object Object]&#x27;// 创建一个没有原型的对象Object.create(null).__proto__ === undefined 对象的深拷贝&ensp;深拷贝没有完美方案，每一种方案都有它的边界case，需要考虑不同数据结构（Array、Object、Map和Set等）的处理 用递归实现深拷贝的核心思路 1234567891011121314151617181920function deepClone(obj) &#123; // 值类型或null if(obj === null || typeof obj !== &#x27;object&#x27;) &#123; return obj &#125; // 定义结果对象 let copy = &#123;&#125; if(obj.constructor === Array) &#123; copy = [] &#125; for(key in obj) &#123; if(obj.hasOwnProperty(key)) &#123; copy[key] = deepClone(obj[key]) &#125; &#125; return copy&#125; 更多内容： 深浅拷贝 结构型：装饰器模式 —— 对象装上它，就像开了挂&ensp;在不改变原对象的基础上，对原对象进行包装拓展使其可以满足用户更复杂的需求 装饰器模式初相见&ensp;为了不被业务逻辑所干扰，应该将旧逻辑与新逻辑分离 12&lt;!-- button --&gt;&lt;button id=&#x27;open&#x27;&gt;点击&lt;/button&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// modalconst Modal = (function() &#123; let modal = null return function() &#123; if(!modal) &#123; modal = document.createElement(&#x27;div&#x27;) modal.innerText = &#x27;modal&#x27; modal.style.display = &#x27;none&#x27; document.body.appendChild(modal) &#125; return modal &#125;&#125;)()// 封装旧逻辑-显示modalclass OpenButton &#123; onClick() &#123; const modal = new Modal() modal.style.display = &#x27;block&#x27; &#125;&#125;// 装饰器-修改按钮的文字和状态class Decorator &#123; constructor(open_button) &#123; this.open_button = open_button // 传入内含旧逻辑的实例 &#125; onClick() &#123; this.open_button.onClick() // 执行-旧逻辑 this.changeButtonStatus() // 执行-新逻辑 &#125; // 整合新逻辑 changeButtonStatus() &#123; this.changeButtonText() this.disableButton() &#125; // 拆分新逻辑 disableButton() &#123; const btn = document.getElementById(&#x27;open&#x27;) btn.setAttribute(&quot;disabled&quot;, true) &#125; changeButtonText() &#123; const btn = document.getElementById(&#x27;open&#x27;) btn.innerText = &#x27;置灰&#x27; &#125;&#125;const openButton = new OpenButton()const decorator = new Decorator(openButton)document.getElementById(&#x27;open&#x27;).addEventListener(&#x27;click&#x27;, function() &#123; decorator.onClick()&#125;) 值得关注的细节&ensp;重要提示：&emsp;在日常开发中，当遇到两段各司其职的代码逻辑时，首先要有“尝试拆分”的敏感，其次要有“该不该拆”的判断，当逻辑粒度过小时，盲目拆分会导致代码中存在过多零碎的小方法，反而不会使代码变得更好 结构型：装饰器模式 —— 深入装饰器原理与优秀案例前置知识：ES7中的装饰器&ensp;在ES7中，可以用 @语法糖 去装饰一个类或一个类的方法 123456789101112131415161718192021222324252627// 装饰器函数function classDecorator(target) &#123; target.hasDecorator = true return target&#125;// 类装饰器@classDecoratorclass Button &#123;&#125; Button.hasDecorator // truefunction funDecorator(target, name, descriptor) &#123; let originalMethod = descriptor.value descriptor.value = function() &#123; console.log(&#x27;装饰器逻辑&#x27;) return originalMethod.apply(this, arguments) &#125; return descriptor&#125;// 方法装饰器Class Button &#123; @funDecorator onClick() &#123; console.log(&#x27;原有逻辑&#x27;) &#125;&#125; const button = new Button() button.onClick() // 装饰器逻辑 原有逻辑 装饰器语法糖背后的故事&ensp;装饰器最基本的操作是定义装饰器函数，将被装饰者“交给”装饰器 装饰器函数传参(1) 类修饰器：第一个参数是目标类(2) 方法装饰器：第一个参数是目标类的原型对象，第二个参数是目标属性名，第三个参数是属性描述对象 装饰器函数的调用时机装饰器函数在编译阶段执行，类的实例在代码运行时动态生成，为了让实例能正常调用被装饰好的类的方法，只能用装饰器去修饰目标类的原型对象 生产实践React中的装饰器：HOC&ensp;HOC（Higher Order Component），高阶组件 编写一个高阶组件，把传入的组件丢进一个有红色边框的容器中 12345678910111213141516// 高阶组件是一个函数，接收一个组件作为参数，并返回一个新组件import React, &#123; Component &#125; from &#x27;react&#x27;const BorderHoc = WrappedComponent =&gt; class extends Component &#123; return() &#123; return &lt;div style=&quot;&#123;&#123; border: &#x27;solid 1px red&#x27; &#125;&#125;&quot;&gt; &lt;WrappedComponent /&gt; &lt;/div&gt; &#125;&#125;// 装饰目标组件@BorderHocclass TargetComponent extends React.Component &#123; render() &#123;&#125;&#125; 用装饰器改写 Redux connect 123456789101112131415161718192021222324252627282930import React, &#123; Component &#125; from &#x27;react&#x27;import &#123; connect &#125; from &#x27;react-redux&#x27;import &#123; bindActionCreators &#125; from &#x27;redux&#x27;import action from &#x27;./action.js&#x27;// 建立组件和状态之间的映射关系function mapStateToProps(state) &#123; return state.app &#125;// 建立组件和store.dispatch的关系，使组件具备通过dispatch来派发状态的能力function mapDispatchToProps(dispatch) &#123; return bindActionCreators(action, dispatch)&#125;/* ------ 原本 ------- */class App extends Component &#123; render() &#123;&#125;&#125;// 调用connect可以返回一个具有装饰作用的函数，接收一个组件作为参数，传入组件与Redux结合，具备Redux提供的数据和能力connect(mapStateToProps, mapDispatchToProps)(App) /* ------ 改写 ------ */// 将调用connect的结果作为一个装饰器const _connect = connect(mapStateToProps, mapDispatchToProps)@_connect class App extends Component &#123; render()&#125; 结构型：适配器模式 —— 兼容代码就是一把梭&ensp;通过把一个类的接口变换成客户端所期待的另一种接口，解决一些兼容性问题 适配器的业务场景&ensp;用适配器承接旧接口的参数，实现新旧接口的无缝衔接 12345678910111213141516171819202122232425262728293031// 旧接口function Ajax(type, url, data, success, failed) &#123; if(type === &#x27;Get&#x27;) &#123;&#125; else if(type === &#x27;Post&#x27;) &#123;&#125;&#125;Ajax(&#x27;get&#x27;, url, data, function(res)&#123;&#125;, function(err)&#123;&#125;)Ajax(&#x27;post&#x27;, url, data, function(res)&#123;&#125;, function(err)&#123;&#125;)// 新接口class HttpUtils &#123; static get(url) &#123;&#125; static post(url, data) &#123;&#125;&#125;// 适配器 - 入参与旧接口保持一致function AjaxAdapter(type, url, data, success, failed) &#123; let res try &#123; if(type === &#x27;Get&#x27;) &#123; res = HttpUtils.get(url) &#125; else if(type === &#x27;Post&#x27;) &#123; res = HttpUtils.post(url, data) &#125; success(res) &#125; catch(err) &#123; failed(err) &#125;&#125;function Ajax(type, url, data, success, failed) &#123; AjaxAdapter(type, url, data, success, failed)&#125; 生产实践：axios中的适配器&ensp;用dispatchRequest方法派发请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 1. 统一接口Axios.prototype.request = function request(config) &#123; return dispatchRequest(newConfig) &#125;// 用getDefaultAdapter方法获取默认适配器var defaults = &#123; adapter: getDefaultAdapter()&#125;function getDefaultAdapter() &#123; var adapter; if (typeof XMLHttpRequest !== &#x27;undefined&#x27;) &#123; // 浏览器环境 adapter = function xhrAdapter(config) &#123; return new Promise(function dispatchXhrRequest(resolve, reject) &#123;&#125;) // 4. 统一规则 &#125; &#125; else if (typeof process !== &#x27;undefined&#x27; &amp;&amp; Object.prototype.toString.call(process) === &#x27;[object process]&#x27;) &#123; // Node环境 adapter = function httpAdapter(config) &#123; return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) &#123;&#125; // 4. 统一规则 &#125; &#125; return adapter; // 3. 统一出参，都是Promise&#125;// 2. 统一入参，调用适配器function dispatchRequest(config) &#123; // 转换请求体 config.data = transformData.call( config, config.data, config.headers, config.transformRequest ); var adapter = config.adapter || defaults.adapter; return adapter(config).then( function onAdapterResolution(response) &#123; // 转换响应体 response.data = transformData.call( config, response.data, response.headers, config.transformResponse ); return response &#125;, function onAdapterRejection(reason) &#123; // 转换响应体 if (reason &amp;&amp; reason.response) &#123; reason.response.data = transformData.call( config, reason.response.data, reason.response.headers, config.transformResponse ) &#125; return Promise.reject(reason) &#125; );&#125; 结构型：代理模式 —— 应用实践范例解析&ensp;一个对象不能直接访问另一个对象，需要第三者牵线搭桥而间接达到访问目的 前置知识 ES6中的Proxy1const proxy = new Proxy(target, handler) // target为目标对象，handler为拦截行为 事件代理&ensp;基于事件冒泡特性，将子元素的事件监听绑定到父元素上，操作不会直接触及目标子元素，而是由父元素进行处理分发后间接作用于子元素 1234&lt;div id=&quot;father&quot;&gt; &lt;a href=&quot;#&quot;&gt;链接1号&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;链接2号&lt;/a&gt; &lt;/div&gt; 123456789101112131415// 未代理，监听每个子元素const aNodes = document.getElementById(&#x27;father&#x27;).getElementsByTagName(&#x27;a&#x27;)for(let i=0;i&lt;aNodes.length;i++) &#123; aNodes[i].addEventListener(&#x27;click&#x27;, function(e) &#123; e.preventDefault() alert(`我是$&#123;aNodes[i].innerText&#125;`) &#125;)&#125;// 代理，只监听父元素document.getElementById(&#x27;father&#x27;).addEventListener(&#x27;click&#x27;, function(e) &#123; if(e.target.tagName === &#x27;A&#x27;) &#123; e.preventDefault() alert(`我是$&#123;e.target.innerText&#125;`) &#125;&#125;) 虚拟代理&ensp;图片预加载时，页面img元素先展示占位图片，创建一个Image实例加载目标图片，然后将页面img元素的src指向目标图片（已缓存） 12345678910111213141516171819202122232425// 操作真实Imageclass PreLoadImage &#123; constructor(imgNode) &#123; this.imgNode = imgNode &#125; setSrc(imgUrl) &#123; this.imgNode.src = imgUrl &#125;&#125;// 接收真实Image，操作虚拟Imageclass ProxyImage &#123; static LOADING_URL = &#x27;xxxxxx&#x27; constructor(targetImage) &#123; this.targetImage = targetImage &#125; setSrc(targetUrl) &#123; this.targetImage.setSrc(ProxyImage.LOADING_URL) // 真实Image初始化显示占位图片 const virtualImage = new Image() // 创建虚拟Image实例 virtualImage.onload = () =&gt; &#123; // 虚拟Image加载完毕，真实Image显示真实图片 this.targetImage.setSrc(targetUrl) &#125; virtualImage.src = targetUrl // 虚拟Image初始化显示真实图片 &#125;&#125; 缓存代理&ensp;对运算结果进行缓存 12345678910111213141516171819202122// 未代理，每次都重新计算const addAll = function() &#123; let result = 0 const len = arguments.length for(let i = 0; i &lt; len; i++) &#123; result += arguments[i] &#125; return result&#125;// 代理，优先从缓存中读取计算结果const proxyAddAll = (function()&#123; const resultCache = &#123;&#125; return function() &#123; const args = Array.prototype.join.call(arguments, &#x27;,&#x27;) if(args in resultCache) &#123; return resultCache[args] &#125; return resultCache[args] = addAll(...arguments) &#125;&#125;)()proxyAddAll(1,2) 保护代理&ensp;在访问层的getter和setter函数里添加校验和拦截，确保一部分变量是安全的 1234567891011121314151617181920212223const person = &#123; age: 18, career: &#x27;teacher&#x27;, phone: 12345654321&#125;const baseInfo = [&#x27;age&#x27;, &#x27;career&#x27;]const privateInfo = [&#x27;phone&#x27;]const user = &#123;isValidated: true, isVIP: false&#125;const accessProxy = new Proxy(person, &#123; get: function(person, key) &#123; if(!user.isValidated) &#123; alert(&#x27;您还没有完成验证哦&#x27;) return &#125; if(!user.isVIP &amp;&amp; privateInfo.indexOf(key)!==-1) &#123; alert(&#x27;只有VIP才可以查看该信息哦&#x27;) return &#125; return person[key] &#125;&#125;) 行为型：策略模式 —— 重构小能手，拆分胖逻辑&ensp;定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换 12345678910111213141516171819202122232425262728293031// 对象映射：把相关算法收敛到一个对象里 // 单一职责原则：各行为函数相互独立，不依赖调用主体const priceProcessor = &#123; processor1(originPrice) &#123; if (originPrice &gt;= 100) &#123; return originPrice - 20 &#125; return originPrice * 0.9 &#125;, processor2(originPrice) &#123; if (originPrice &gt;= 100) &#123; return originPrice - 30 &#125; return originPrice * 0.8 &#125;&#125;;// 通过委托实现行为分发function askPrice(tag, originPrice) &#123; return priceProcessor[tag](originPrice)&#125;// 扩展：开发封闭原则priceProcessor.processor3 = function(originPrice) &#123; if (originPrice &gt;= 100) &#123; return originPrice - 50 &#125; return originPrice&#125;askPrice(&#x27;processor3&#x27;, 150) // 100 行为型：状态模式 —— 自主咖啡机背后的力量&ensp;允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类 1234567891011121314151617181920212223242526272829303132class CoffeeMaker &#123; constructor() &#123; this.state = &#x27;init&#x27; this.excessMile = &#x27;1000ml&#x27; // 主体状态 &#125; // 单一职责原则：各行为函数可能不会特别割裂，和状态主体之间存在着关联 stateToProcess = &#123; that: this, american() &#123; console.log(&#x27;咖啡机现在的牛奶存储量是:&#x27;, this.that.leftMilk) // 获取主体状态 console.log(&#x27;我只吐黑咖啡&#x27;) &#125; latte() &#123; this.american() console.log(&#x27;加点奶&#x27;) &#125;, mocha() &#123; this.latte(); console.log(&#x27;加点巧克力&#x27;) &#125; changeState(state) &#123; // 状态切换函数 this.state = state if (!this.stateToProcessor[state]) &#123; return &#125; this.stateToProcessor[state]() &#125; &#125;&#125;const mk = new CoffeeMaker();mk.changeState(&#x27;latte&#x27;); 行为型：观察者模式 —— 鬼故事：产品经理拉了一个钉钉群&ensp;观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新，发布者可以直接触及到订阅者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* ------ 角色划分 状态变化 发布者通知订阅者 ------ */// 抽象的发布者类class Publisher &#123; constructor() &#123; this.observers = [] // *维护订阅者的集合 console.log(&#x27;Publisher created&#x27;) &#125; addObserver(observer) &#123; // 增加订阅者 console.log(&#x27;Publisher.addObserver invoked&#x27;) this.observers.push(observer) &#125; removeObserver(observer) &#123; // 移除订阅者 console.log(&#x27;Publisher.removeObserver invoked&#x27;) this.observers.forEach((item, i) =&gt; &#123; if (item === observer) &#123; this.observers.splice(i, 1) &#125; &#125;) &#125; notifyObserver() &#123; // 通知所有订阅者 console.log(&#x27;Publisher.notifyObserver invoked&#x27;) this.observers.forEach((observer) =&gt; &#123; observer.update(this) &#125;) &#125;&#125;// 抽象的订阅者类class Observer &#123; constructor() &#123; console.log(&#x27;Observer created&#x27;) &#125; update() &#123; console.log(&#x27;Observer.update invoked&#x27;) // *提供统一方法供发布者调用 &#125;&#125;// 具体的发布者类class SpPublisher extends Publisher &#123; constructor() &#123; super() this.state = null console.log(&#x27;SpPublisher created&#x27;) &#125; getState() &#123; console.log(&#x27;SpPublisher.getState invoked&#x27;) return this.state &#125; setState(state) &#123; console.log(&#x27;SpPublisher.setState invoked&#x27;) this.state = state this.notifyObserver() &#125;&#125;// 具体的订阅者类class SpObserver extends Observer &#123; constructor() &#123; super() this.state = null console.log(&#x27;SpObserver created&#x27;) &#125; update(publisher) &#123; console.log(&#x27;SpObserver.update invoked&#x27;) this.state = publisher.getState() this.do() &#125; do() &#123; console.log(&#x27;SpObserver.do invoked&#x27;) console.log(this.state) &#125;&#125;const publisher = new SpPublisher()const observer1 = new SpObserver()const observer2 = new SpObserver()publisher.addObserver(observer1)publisher.addObserver(observer2)publisher.setState(&#x27;go!!!&#x27;) 行为型：观察者模式 —— 面试真题手把手教学Vue数据双向绑定（响应式系统）的实现原理&ensp;“发布-订阅”模式：发布者不直接触及到订阅者，而是由统一的第三方完成实际的通信操作,实现了完全地解耦 三个关键角色：监听器、订阅者、编译器(1) observer监听器：监听数据并转发给订阅者（发布者）(2) watcher订阅者：接收数据并更新视图(3) compile编译器：初始化视图，更新订阅者… 核心代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// observer：在init阶段，对数据进行响应式化function observer(target) &#123; if(target &amp;&amp; typeof target === &#x27;object&#x27;) &#123; Object.keys(target).forEach((key)=&gt;&#123; defineReactive(target, key, target[key]) &#125;) &#125;&#125;function defineReactive(target, key, val) &#123; const dep = new Dep() observer(val) Object.defineProperty(target, key, &#123; enumerable: true, configurable: false, get: function() &#123; dep.addSub(Dep.target) // 依赖收集：将watcher对象存放到dep中 return val &#125;, set: function(value) &#123; // 通过setter -&gt; Watcher -&gt; update的流程来修改视图 if(val !== value) &#123; val = value dep.notify() &#125; &#125; &#125;)&#125;// Dep：订阅者收集器（发布者）class Dep &#123; constructor() &#123; this.subs = [] //存放watcher &#125; addSub(sub) &#123; this.subs.push(sub) &#125; notify() &#123; this.subs.forEach((sub)=&gt;&#123; sub.update() &#125;) &#125;&#125;// watcher: 订阅者（观察者)class Watcher &#123; constructor() &#123; Dep.target = this &#125; update() &#123; console.log(&quot;视图更新啦～&quot;) &#125;&#125;// Vue dataclass Vue &#123; constructor(options) &#123; this._data = options.data observer(this._data) new Watcher() console.log(&#x27;render:&#x27;, this._data.test) // 模拟渲染，触发get &#125;&#125;let obj = new Vue(&#123; data: &#123; test: 1 &#125;&#125;)obj._data.test = 2// 全局事件总线 Event Bus：所有事件的发布/订阅操作必须经由事件中心class EventBus &#123; constructor() &#123; this.handlers = &#123;&#125; // 存储事件与回调的对应关系 &#125; on(eventName, callback) &#123; if(!this.handlers[eventName]) &#123; this.handlers[eventName] = [] // 初始化监听函数队列 &#125; this.handlers[eventName].push(callback) &#125; emit(eventName, ...args) &#123; if(this.handlers[eventName]) &#123; const handlers = this.handlers[eventName].slice() // 浅拷贝，避免once移除监听器时弄乱顺序 handlers.forEach((callback) =&gt; &#123; // 逐个调用监听函数队列里的回调函数 callback(...args) &#125;) /* this.handlers[eventName].forEach((callback) =&gt; &#123; callback(...args) &#125;) */ &#125; &#125; off(eventName, callback) &#123; // 移除监听函数队列里的指定回调函数 const callbacks = this.handlers[eventName] const index = callbacks.indexOf(callback) if (index !== -1) &#123; callbacks.splice(index, 1) &#125; &#125; once(eventName, callback) &#123; // 单次监听 const wrapper = (...args) =&gt; &#123; callback(...args) this.off(eventName, wrapper) &#125; this.on(eventName, wrapper) &#125;&#125;let bus = new EventBus()function getNum(num) &#123; console.log(&#x27;get:&#x27;, num)&#125;bus.on(&#x27;event1&#x27;, getNum)bus.emit(&#x27;event1&#x27;, 8)bus.once(&#x27;event2&#x27;, getNum)bus.emit(&#x27;event2&#x27;, 10) 行为型：迭代器模式 —— 真·遍历专家&ensp;迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示 ES6对迭代器的实现&ensp;ES6约定，任何数据结构只要具备Symbol.iterator属性，就可以通过迭代器.next()和for(…of…)进行遍历 1234567891011121314const arr = [1, 2, 3]// 迭代器.next()const iterator = arr[Symbol.iterator]()let now = &#123; done: false &#125;while(!now.done) &#123; now = iterator.next() if(!now.done) &#123; console.log(`现在遍历到了$&#123;now.value&#125;`) &#125;&#125;// for(...of...)for(item of arr) &#123; // 实际是next方法的反复调用 console.log(`当前元素是$&#123;item&#125;`)&#125; 实现一个迭代器生成函数123456789101112131415// 通过闭包记录每次遍历的位置function iteratorGenerator(list) &#123; var idx = 0 var len = list.length return &#123; next: function() &#123; var done = idx &gt;= len var value = !done ? list[idx++] : undefined return &#123; done: done, value: value &#125; &#125; &#125;&#125; 参考链接 vue.use()方法从源码到使用 vuex 实现原理 响应式系统的基本原理 响应式系统的依赖收集追踪原理","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Zyx"},{"title":"deepmerge源码解析","slug":"deepmerge源码解析","date":"2021-10-08T08:45:41.000Z","updated":"2022-02-19T08:57:58.267Z","comments":true,"path":"a519f8f.html","link":"","permalink":"http://example.com/a519f8f.html","excerpt":"","text":"一. 介绍deepmerge: 以深拷贝的方式，合并两个或多个对象的可枚举属性。 二. 模块加载，CommonJs规范：module.exports = deepmerge; 三. 主要流程1234567891011121314151617181920function deepmerge(target, source, options) &#123; options = options || &#123;&#125; options.arrayMerge = options.arrayMerge || defaultArrayMerge options.isMergeableObject = options.isMergeableObject || defaultIsMergeableObject // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge() // implementations can use it. The caller may not replace it. options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified var sourceIsArray = Array.isArray(source) var targetIsArray = Array.isArray(target) var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray if (!sourceAndTargetTypesMatch) &#123; return cloneUnlessOtherwiseSpecified(source, options) &#125; else if (sourceIsArray) &#123; return options.arrayMerge(target, source, options) &#125; else &#123; return mergeObject(target, source, options) &#125;&#125; 1. 判断target和source的类型主要分为：（1）source和target是不同的类型，执行cloneUnlessOtherwiseSpecified(source, options)；（2）source和target都是数组类型，执行options.arrayMerge(target, source, options)；（3）sourc和target都是Object类型，执行mergeObject(target, source, options)。 1234567891011121314151617181920function mergeObject(target, source, options) &#123; var destination = &#123;&#125; if (options.isMergeableObject(target)) &#123; getKeys(target).forEach(function(key) &#123; destination[key] = cloneUnlessOtherwiseSpecified(target[key], options) &#125;) &#125; getKeys(source).forEach(function(key) &#123; if (propertyIsUnsafe(target, key)) &#123; return &#125; if (propertyIsOnObject(target, key) &amp;&amp; options.isMergeableObject(source[key])) &#123; destination[key] = getMergeFunction(key, options)(target[key], source[key], options) &#125; else &#123; destination[key] = cloneUnlessOtherwiseSpecified(source[key], options) &#125; &#125;) return destination&#125; 2. mergeObject(target, source, options)（1）对target对象执行深拷贝操作；（2）遍历source对象，如果key值是在target原型链中存在，直接返回；如果key值是target中自有属性且可以合并，则执行 getMergeFunction(key, options)(target[key], source[key], options)；否则直接将source属性深拷贝到target中，执行 cloneUnlessOtherwiseSpecified(source[key], options)。 12345function cloneUnlessOtherwiseSpecified(value, options) &#123; return (options.clone !== false &amp;&amp; options.isMergeableObject(value)) ? deepmerge(emptyTarget(value), value, options) : value&#125; 3. cloneUnlessOtherwiseSpecified(value, options)将source中存在，而target中不存在的属性直接以一个空Object，进行深拷贝合并。 12345function defaultArrayMerge(target, source, options) &#123; return target.concat(source).map(function(element) &#123; return cloneUnlessOtherwiseSpecified(element, options) &#125;)&#125; 4. 数组合并对target和source两个数组执行concat操作，然后对每个值执行深拷贝cloneUnlessOtherwiseSpecified(element, options) 123456789deepmerge.all = function deepmergeAll(array, options) &#123; if (!Array.isArray(array)) &#123; throw new Error(&#x27;first argument should be an array&#x27;) &#125; return array.reduce(function(prev, next) &#123; return deepmerge(prev, next, options) &#125;, &#123;&#125;)&#125; 5. deepmerge.all对多个对象执行深拷贝操作，这里直接将all函数作为deepmerge函数的一个属性 四. 补充知识点deemerge 就是一个考虑全面、比较通用的深拷贝实现【比如source和target不同类型、能否merge、包含原型对象属性、预留自定义merge方法等】。代码本身比较精炼，值得学习参考。 1. getKeys考虑了Symbol属性1234567891011function getEnumerableOwnPropertySymbols(target) &#123; return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) &#123; return target.propertyIsEnumerable(symbol) &#125;) : []&#125;function getKeys(target) &#123; return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))&#125; 2. 属性是否位于原型链上，自由属性是否可枚举1234567891011121314function propertyIsOnObject(object, property) &#123; try &#123; return property in object &#125; catch(_) &#123; return false &#125;&#125;// Protects from prototype poisoning and unexpected merging up the prototype chain.function propertyIsUnsafe(target, key) &#123; return propertyIsOnObject(target, key) // Properties are safe to merge if they don&#x27;t exist in the target yet, &amp;&amp; !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain, &amp;&amp; Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they&#x27;re nonenumerable.&#125; 参考文献[1] deepmerge的npm官方文档","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"源码","slug":"源码","permalink":"http://example.com/tags/%E6%BA%90%E7%A0%81/"}],"author":"Lzb"},{"title":"IDE常用快捷键","slug":"IDE常用快捷键","date":"2021-09-14T07:43:40.000Z","updated":"2022-02-19T08:57:58.267Z","comments":true,"path":"5028d3ef.html","link":"","permalink":"http://example.com/5028d3ef.html","excerpt":"","text":"VSCode折叠与展开区域内所有代码12Ctrl + K + 0 // 折叠 Ctrl + K + J // 展开 折叠与展开某块区域代码12Ctrl + K + [ // 折叠 Ctrl + K + ] // 展开 视图上下偏移12Ctrl + Up , Ctrl + Down // 行视图，幅度较小Alt + PageUp , Alt + PageDown // 屏视图，幅度较大 移动当前行的位置12Alt + Up // 向上移一行 Alt + Down // 向下移一行 复制当前行12Shift + Alt + Up // 复制到前一行Shift + Alt + Down // 复制到后一行 基于当前行插入一行12Ctrl + Shift + Enter // 之前插入Ctrl + Enter // 之后插入 搜索与跳转12Ctrl + P + &quot;str&quot; // 搜索名称包含str的文件Ctrl + P + &quot;:n&quot; // 跳转到第n行 查询与替换123/* 选中内容会默认填入框内 */Ctrl + F // 查询Ctrl + H // 替换","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://example.com/tags/%E6%95%88%E7%8E%87/"}],"author":"Zyx"},{"title":"前端性能分析","slug":"前端性能分析","date":"2021-09-11T08:07:41.000Z","updated":"2022-02-19T08:57:58.270Z","comments":true,"path":"dd85c073.html","link":"","permalink":"http://example.com/dd85c073.html","excerpt":"","text":"一些图1. Lighthouse界面 2. Performance界面 3. 指标解析 一些概念1. 长任务W3C性能工作组在LongTask规范中将超过50ms的任务定义为长任务。 2. FPSFrames Per Second，每秒帧率，表示每秒种画面的更新次数，大多数设备的屏幕刷新率都是60次/秒。 3. 时间切片(1) 核心思想： 如果一个任务不能在50ms内执行完，那么为了不阻塞主线程，它应该让出主线程的控制权（即停止执行这个任务），浏览器会先去处理其它任务，然后再回来继续执行未完成的任务。(2) 技术手段：将一个长任务拆分成很多个不超过50ms的小任务，分散在宏任务队列中执行。(3) 优、缺点：优点是可以避免卡死浏览器；缺点是任务运行的总时间变长（每处理完一个小任务，主线程会空闲出来，而且在下一个小任务开始处理之前有一小段延时）。(4) 代码实现： 123456789101112131415161718192021222324252627282930/* 用ES6的Generator函数 */ function someThing() &#123; console.log(&#x27;someThing&#x27;);&#125;function otherThing() &#123; console.log(&#x27;otherThing&#x27;);&#125;function ts (gen) &#123; if (typeof gen === &#x27;function&#x27;) gen = gen(); if (!gen || typeof gen.next !== &#x27;function&#x27;) return; return function next() &#123; const res = gen.next(); if (res.done) return; setTimeout(function () &#123; next(); &#125;, 1000); &#125;&#125;ts(function* doing() &#123; const start = performance.now(); while (performance.now() - start &lt; 10000) &#123; someThing(); yield; // 暂停执行 otherThing(); &#125; console.log(&#x27;done!&#x27;);&#125;)(); 一些方法1. 获取LCP12345new PerformanceObserver((entryList) =&gt; &#123; for (const entry of entryList.getEntries()) &#123; console.log(&quot;LCP candidate:&quot;, entry.startTime); &#125;&#125;).observe(&#123; type: &quot;largest-contentful-paint&quot;, buffered: true &#125;); 2. 获取FID12345678910111213141516171819202122232425262728293031/* --- 方法一：通过PerformanceObserver --- */new PerformanceObserver((entryList) =&gt; &#123; for (const entry of entryList.getEntries()) &#123; const delay = entry.processingStart - entry.startTime; console.log(&quot;FID candidate:&quot;, delay); &#125;&#125;).observe(&#123; type: &quot;first-input&quot;, buffered: true &#125;);/* --- 方法二：通过&lt;head&gt;&lt;/head&gt;内监听用户交互事件 --- */[&#x27;click&#x27;,&#x27;mousedown&#x27;,&#x27;touchstart&#x27;,&#x27;keydown&#x27;, &#x27;pointerdown&#x27;].forEach(eventType =&gt; &#123; window.addEventListener(eventType, eventHandle);&#125;);function eventHandle(e)&#123; /* --- 1. 通过performance.getEntriesByType(&#x27;first-input&#x27;) --- */ console.log(performance.getEntriesByType(&#x27;first-input&#x27;)[0].startTime); console.log(performance.getEntriesByType(&#x27;first-input&#x27;)[0].duration); /* --- 2. 通过timeStamp --- */ const eventTime = e.timeStamp; window.requestIdleCallback(onIdleCallback.bind(this, eventTime, e)); // 实验功能，用于在浏览器空闲时间执行回调函数 function onIdleCallback(eventTime, e) &#123; const now = performance.now(); const duration = now - eventTime; return &#123; timeStamp: eventTime, duration: duration &#125; &#125;&#125;; 3. 获取CLS123456789let cls = 0;new PerformanceObserver((entryList) =&gt; &#123; for (const entry of entryList.getEntries()) &#123; if (!entry.hadRecentInput) &#123; // 500ms内是否有用户数据 cls += entry.value; console.log(&quot;Current CLS value:&quot;, cls); &#125; &#125;&#125;).observe(&#123; type: &quot;layout-shift&quot;, buffered: true &#125;); 4. 获取FP1console.log(performance.getEntriesByType(&#x27;paint&#x27;)[0].startTime); 5. 获取FCP12345678910111213141516171819202122232425262728293031/* --- 方法一：通过performance.getEntriesByType(&#x27;paint&#x27;) --- */ console.log(performance.getEntriesByType(&#x27;paint&#x27;)[1].startTime);/* --- 方法二：通过Mutation Observer --- */let insertedNodes = [];let observer = new MutationObserver(function(mutations) &#123; mutations.forEach(function(mutation) &#123; for (let i = 0; i &lt; mutation.addedNodes.length; i++) &#123; mutation.addedNodes[i][&#x27;time&#x27;] = performance.now(); // 手动添加时间戳 insertedNodes.push(mutation.addedNodes[i]); &#125; &#125;);&#125;);setTimeout(()=&gt;&#123; observer.disconnect(); //停止监听&#125;);observer.observe(document.documentElement, &#123; childList: true, subtree: true &#125;); // 开始监听let timer = setInterval(()=&gt;&#123; if(insertedNodes.length)&#123; clearInterval(timer); for(let i=0;i&lt;insertedNodes.length; i++)&#123; if(insertedNodes[i].className === &#x27;container&#x27;)&#123; console.log(insertedNodes[i].time); // 获取某个元素的时间戳 break; &#125; &#125;; &#125;&#125;, 100); 6. 获取TTI1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* --- 方法一：通过安装npm包tti-polyfill或script标签引入tti-polyfill.js --- */&lt;script&gt; !function()&#123; // 创建PerformanceObserver实例观察longtask if(&#x27;PerformanceLongTaskTiming&#x27; in window)&#123; var g = window.__tti=&#123; e:[] &#125;; g.o = new PerformanceObserver(function(l)&#123; g.e = g.e.concat(l.getEntries()); &#125;); g.o.observe(&#123; entryTypes:[&#x27;longtask&#x27;] &#125;) &#125; &#125;();&lt;/script&gt;ttiPolyfill.getFirstConsistentlyInteractive().then((tti) =&gt; &#123; console.log(tti);&#125;);/* --- 方法二：在页面加载的一段时间loadTime内，以(domContentLoadedEventStart-navigationStart)+basicTime为起始点进行循环查找，直到找到一个网络请求不超过2个且没有长任务的窗口，该窗口之前的最后一个长任务结束的时间点就是可稳定交互时间 --- */const basicTime = 5000, loadTime = 50000;function getTTItime(startTime, longTaskEntries, resourceEntries, domContentLoadedTime) &#123; // 伪代码 let tti = startTime; while(startTime + basicTime &lt;= loadTime) &#123; tti = startTime; // 长任务 let longTasksInWindow = longTaskEntries.filter(task =&gt; &#123; return task.startTime &lt; startTime + basicTime &amp;&amp; task.startTime + task.duration &gt; startTime; &#125;); if (longTasksInWindow.length) &#123; const lastLongTask = longTasksInWindow[longTasksInWindow.length - 1]; startTime = lastLongTask.startTime + lastLongTask.duration; continue; &#125; // 网络请求超过2个 let busyNetworkInWindow = resourceEntries.filter(request =&gt; &#123; return !(request.startTime &gt;= startTime + basicTime || request.startTime + request.duration &lt;= startTime); &#125;); if (busyNetworkInWindow.length &gt; 2) &#123; const firstRequest = busyNetworkInWindow[0]; startTime = firstRequest.startTime + firstRequest.duration; continue; &#125; return Math.max(tti, domContentLoadedTime); &#125; return Math.max(tti, domContentLoadedTime);&#125; 参考链接Web性能领域常见的专业术语捕获FMP的原理时间切片 ( Time Slicing ) 使用 Lighthouse 分析前端性能前端性能优化之谈谈常见的性能指标及上报策略补齐Web前端性能分析的工具盲点Mutation Observer API解读新一代 Web 性能体验和质量指标2021 年 Web 核心性能指标是什么？谷歌工程师告诉你，FMP 过时啦！Chrome的Performance面板","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"性能","slug":"性能","permalink":"http://example.com/tags/%E6%80%A7%E8%83%BD/"}],"author":"Zyx"},{"title":"hexo配置","slug":"hexo配置","date":"2021-09-06T06:09:41.000Z","updated":"2022-02-19T08:57:58.268Z","comments":true,"path":"b5a0661a.html","link":"","permalink":"http://example.com/b5a0661a.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 一. 常用操作Create123$ hexo new post &quot;source/_posts&quot;$ hexo new page &quot;source&quot;$ hexo new draft &quot;source/_drafts&quot; Clean1$ hexo clean Publish1hexo publish draft &quot;source/_drafts&quot; Generate static files1$ hexo generate Run server1$ hexo server Deploy to remote sites1$ hexo deploy 二. hexo插件hexo添加永久链接之abbrlinkhexo添加搜索功能之hexo-generator-json-contenthexo添加评论功能之utterances","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"配置","slug":"配置","permalink":"http://example.com/tags/%E9%85%8D%E7%BD%AE/"}],"author":"Zyx"}],"categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF/"},{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"源码","slug":"源码","permalink":"http://example.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"知识点","slug":"知识点","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"效率","slug":"效率","permalink":"http://example.com/tags/%E6%95%88%E7%8E%87/"},{"name":"性能","slug":"性能","permalink":"http://example.com/tags/%E6%80%A7%E8%83%BD/"},{"name":"配置","slug":"配置","permalink":"http://example.com/tags/%E9%85%8D%E7%BD%AE/"}]}